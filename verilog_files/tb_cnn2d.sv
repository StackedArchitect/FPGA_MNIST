`timescale 1ns / 1ps
//============================================================================
// Testbench for 2D CNN
//
// Architecture: Conv2D_1(1→4, 3×3) → Pool2D(2×2) → Conv2D_2(4→8, 3×3)
//               → Pool2D(2×2) → FC1(200→32) → FC2(32→10)
//
// Loads .mem files generated by cnn2d_model.py, runs inference, reports result.
//============================================================================
module tb_cnn2d;

    // ---- Architecture parameters (must match cnn2d_top) ----
    parameter INPUT_H       = 28;
    parameter INPUT_W       = 28;
    parameter INPUT_CH      = 1;

    parameter CONV1_OUT_CH  = 4;
    parameter CONV1_KERNEL  = 3;
    parameter CONV1_OUT_H   = INPUT_H - CONV1_KERNEL + 1;  // 26
    parameter CONV1_OUT_W   = INPUT_W - CONV1_KERNEL + 1;  // 26

    parameter POOL1_SIZE    = 2;
    parameter POOL1_OUT_H   = CONV1_OUT_H / POOL1_SIZE;    // 13
    parameter POOL1_OUT_W   = CONV1_OUT_W / POOL1_SIZE;    // 13

    parameter CONV2_IN_CH   = CONV1_OUT_CH;                 // 4
    parameter CONV2_OUT_CH  = 8;
    parameter CONV2_KERNEL  = 3;
    parameter CONV2_OUT_H   = POOL1_OUT_H - CONV2_KERNEL + 1;  // 11
    parameter CONV2_OUT_W   = POOL1_OUT_W - CONV2_KERNEL + 1;  // 11

    parameter POOL2_SIZE    = 2;
    parameter POOL2_OUT_H   = CONV2_OUT_H / POOL2_SIZE;    // 5
    parameter POOL2_OUT_W   = CONV2_OUT_W / POOL2_SIZE;    // 5

    parameter FLATTEN_SIZE  = POOL2_OUT_H * POOL2_OUT_W * CONV2_OUT_CH;  // 200
    parameter FC1_OUT       = 32;
    parameter FC2_OUT       = 10;
    parameter PAD           = 20;

    parameter FC1_WIDTH       = PAD + FLATTEN_SIZE + PAD - 1;  // 239
    parameter FC1_COUNTER_END = FC1_WIDTH - 3;                 // 236
    parameter FC2_WIDTH       = PAD + FC1_OUT + PAD - 1;       // 71
    parameter FC2_COUNTER_END = FC2_WIDTH - 3;                 // 68

    parameter BITS         = 31;
    localparam OUTPUT_BITS = BITS + 8 + 8;  // Two FC layers add 8 bits each

    // Timing — conv2d layers: 26×26×9 + 13×13×4 + 11×11×36 + 5×5×4 + FC ≈ 12000 cycles
    parameter CLK_PERIOD_NS   = 10;
    parameter SIM_DURATION_NS = 200000;  // Generous for safety

    // ---- DUT signals ----
    reg  clk;
    reg  rstn;

    // Input image — 28×28 = 784 Q16.16 values
    reg signed [31:0] data_in [0 : INPUT_H * INPUT_W * INPUT_CH - 1];

    // Conv2D weights & biases
    reg signed [31:0] conv1_w [0 : CONV1_OUT_CH * INPUT_CH * CONV1_KERNEL * CONV1_KERNEL - 1];
    reg signed [31:0] conv1_b [0 : CONV1_OUT_CH - 1];
    reg signed [31:0] conv2_w [0 : CONV2_OUT_CH * CONV2_IN_CH * CONV2_KERNEL * CONV2_KERNEL - 1];
    reg signed [31:0] conv2_b [0 : CONV2_OUT_CH - 1];

    // FC weights & biases (2D arrays with padding)
    reg signed [31:0] fc1_w [0 : FC1_OUT - 1][0 : FC1_WIDTH];
    reg signed [31:0] fc1_b [0 : FC1_OUT - 1];
    reg signed [31:0] fc2_w [0 : FC2_OUT - 1][0 : FC2_WIDTH];
    reg signed [31:0] fc2_b [0 : FC2_OUT - 1];

    // Output
    wire signed [BITS+8:0] cnn_out [0 : FC2_OUT - 1];

    // ---- DUT instantiation ----
    cnn2d_top #(
        .INPUT_H      (INPUT_H),
        .INPUT_W      (INPUT_W),
        .INPUT_CH     (INPUT_CH),
        .CONV1_OUT_CH (CONV1_OUT_CH),
        .CONV1_KERNEL (CONV1_KERNEL),
        .POOL1_SIZE   (POOL1_SIZE),
        .CONV2_IN_CH  (CONV2_IN_CH),
        .CONV2_OUT_CH (CONV2_OUT_CH),
        .CONV2_KERNEL (CONV2_KERNEL),
        .POOL2_SIZE   (POOL2_SIZE),
        .FC1_OUT      (FC1_OUT),
        .FC2_OUT      (FC2_OUT),
        .PAD          (PAD),
        .BITS         (BITS)
    ) dut (
        .clk      (clk),
        .rstn     (rstn),
        .data_in  (data_in),
        .conv1_w  (conv1_w),
        .conv1_b  (conv1_b),
        .conv2_w  (conv2_w),
        .conv2_b  (conv2_b),
        .fc1_w    (fc1_w),
        .fc1_b    (fc1_b),
        .fc2_w    (fc2_w),
        .fc2_b    (fc2_b),
        .cnn_out  (cnn_out)
    );

    // ---- Clock ----
    initial clk = 1'b0;
    always #(CLK_PERIOD_NS / 2) clk = ~clk;

    // ---- Temp flat arrays for loading FC weights ----
    localparam FC1_ENTRIES = FC1_WIDTH + 1;  // 240
    localparam FC2_ENTRIES = FC2_WIDTH + 1;  // 72

    reg signed [31:0] fc1_w_flat [0 : FC1_OUT * FC1_ENTRIES - 1];
    reg signed [31:0] fc2_w_flat [0 : FC2_OUT * FC2_ENTRIES - 1];

    // ---- Argmax vars ----
    integer detected_digit;
    integer n;
    reg signed [BITS+8:0] max_val;

    // Expected label
    reg [31:0] expected_label_arr [0:0];
    integer    expected_label;

    integer row, col;

    // ---- Argmax task ----
    task find_predicted_digit;
        begin
            max_val = cnn_out[0];
            detected_digit = 0;
            for (n = 1; n < FC2_OUT; n = n + 1) begin
                if (cnn_out[n] > max_val) begin
                    max_val = cnn_out[n];
                    detected_digit = n;
                end
            end
        end
    endtask

    // ---- Display task ----
    task display_all_outputs;
        begin
            $display("============================================================");
            $display("  2D CNN OUTPUT VALUES  (Q16.16 raw logits)");
            $display("============================================================");
            for (n = 0; n < FC2_OUT; n = n + 1) begin
                $display("  Output[%0d] (digit %0d) = %0d", n, n, cnn_out[n]);
            end
            $display("============================================================");
        end
    endtask

    // ---- Main stimulus ----
    initial begin
        $display("\n============================================================");
        $display("  2D CNN TESTBENCH — LOADING DATA");
        $display("============================================================\n");

        // ---- Load conv2d weights ----
        $display("[INFO] Loading Conv1 weights (conv1_w.mem) — %0d entries ...",
                 CONV1_OUT_CH * INPUT_CH * CONV1_KERNEL * CONV1_KERNEL);
        $readmemh("conv1_w.mem", conv1_w);

        $display("[INFO] Loading Conv1 biases (conv1_b.mem) — %0d entries ...",
                 CONV1_OUT_CH);
        $readmemh("conv1_b.mem", conv1_b);

        $display("[INFO] Loading Conv2 weights (conv2_w.mem) — %0d entries ...",
                 CONV2_OUT_CH * CONV2_IN_CH * CONV2_KERNEL * CONV2_KERNEL);
        $readmemh("conv2_w.mem", conv2_w);

        $display("[INFO] Loading Conv2 biases (conv2_b.mem) — %0d entries ...",
                 CONV2_OUT_CH);
        $readmemh("conv2_b.mem", conv2_b);

        // ---- Load FC weights (flat → 2D) ----
        $display("[INFO] Loading FC1 weights (fc1_w.mem) — %0d neurons × %0d entries ...",
                 FC1_OUT, FC1_ENTRIES);
        $readmemh("fc1_w.mem", fc1_w_flat);
        for (row = 0; row < FC1_OUT; row = row + 1)
            for (col = 0; col < FC1_ENTRIES; col = col + 1)
                fc1_w[row][col] = fc1_w_flat[row * FC1_ENTRIES + col];

        $display("[INFO] Loading FC1 biases (fc1_b.mem) — %0d biases ...", FC1_OUT);
        $readmemh("fc1_b.mem", fc1_b);

        $display("[INFO] Loading FC2 weights (fc2_w.mem) — %0d neurons × %0d entries ...",
                 FC2_OUT, FC2_ENTRIES);
        $readmemh("fc2_w.mem", fc2_w_flat);
        for (row = 0; row < FC2_OUT; row = row + 1)
            for (col = 0; col < FC2_ENTRIES; col = col + 1)
                fc2_w[row][col] = fc2_w_flat[row * FC2_ENTRIES + col];

        $display("[INFO] Loading FC2 biases (fc2_b.mem) — %0d biases ...", FC2_OUT);
        $readmemh("fc2_b.mem", fc2_b);

        // ---- Load input & label ----
        $display("[INFO] Loading input data (data_in.mem) — %0d pixels (28×28) ...",
                 INPUT_H * INPUT_W);
        $readmemh("data_in.mem", data_in);

        $display("[INFO] Loading expected label (expected_label.mem) ...");
        $readmemh("expected_label.mem", expected_label_arr);
        expected_label = expected_label_arr[0];
        $display("[INFO] Expected label: %0d\n", expected_label);

        // ---- Reset ----
        $display("[INFO] Applying reset ...");
        rstn = 1'b0;
        #(CLK_PERIOD_NS * 2);
        rstn = 1'b1;
        $display("[INFO] Reset released at %0t ns. Inference running ...\n", $time);

        // ---- Wait for inference ----
        #(SIM_DURATION_NS);

        // ---- Results ----
        $display("\n");
        $display("############################################################");
        $display("#         2D CNN INFERENCE COMPLETE - RESULTS              #");
        $display("############################################################\n");

        display_all_outputs;
        find_predicted_digit;

        $display("");
        $display("  >>> DETECTED DIGIT: %0d <<<", detected_digit);
        $display("  >>> Confidence (raw Q16.16 logit): %0d <<<", max_val);
        $display("");
        $display("  --- EXPECTED DIGIT: %0d ---", expected_label);
        $display("");
        if (detected_digit == expected_label)
            $display("  *** RESULT: PASS — Prediction matches expected label! ***");
        else
            $display("  *** RESULT: FAIL — Expected %0d but got %0d ***",
                     expected_label, detected_digit);
        $display("");
        $display("############################################################\n");

        #(CLK_PERIOD_NS * 2);
        $finish;
    end

    // ---- Monitor layer done signals ----
    always @(posedge dut.conv1_done) begin
        $display("[INFO] Conv1  DONE at %0t ns. Pool1 starting ...", $time);
    end
    always @(posedge dut.pool1_done) begin
        $display("[INFO] Pool1  DONE at %0t ns. Conv2 starting ...", $time);
    end
    always @(posedge dut.conv2_done) begin
        $display("[INFO] Conv2  DONE at %0t ns. Pool2 starting ...", $time);
    end
    always @(posedge dut.pool2_done) begin
        $display("[INFO] Pool2  DONE at %0t ns. FC1 starting ...", $time);
    end
    always @(posedge dut.fc1_done) begin
        $display("[INFO] FC1    DONE at %0t ns. FC2 starting ...", $time);
    end

endmodule
